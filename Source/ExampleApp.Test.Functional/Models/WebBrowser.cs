using OpenQA.Selenium;
using OpenQA.Selenium.Chrome;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

namespace ExampleApp.Test.Functional.Models
{
    /// <summary>
    /// Models a web browser.
    /// </summary>
    public class WebBrowser : IDisposable
    {
        /// <summary>
        /// Defines the name of constant field that each class inheriting WebPage must implement.
        /// </summary>
        private const string WebPageRelativePathConstantName = "RelativePath";

        /// <summary>
        /// Maintains the collection of classes inheriting the WebPage class, keyed on their RelativePaths.
        /// This is done so that instances of these types can be instantiated from a given relative path.
        /// </summary>
        private static readonly Dictionary<string, Type> WellKnownPages;

        /// <summary>
        /// Reference to the IWebDriver to use for controlling the browser.
        /// </summary>
        private readonly IWebDriver _webBrowserDriver;

        /// <summary>
        /// The default base URI of the target website, will be used with relative paths.
        /// </summary>
        private readonly Uri        _baseUri;

        /// <summary>
        /// Initializes the WebBrowser class by taking inventory of all the classes inheriting from the WebPage class.
        /// </summary>
        static WebBrowser()
        {
            WellKnownPages = GetWellKnownPages();
        }

        /// <summary>
        /// Initializes an instance of this type with a default base URI.
        /// </summary>
        /// <param name="baseUri">Specifies the base URI that will be used with all relative paths.</param>
        public 
        WebBrowser(Uri baseUri)
        {
            _baseUri          = baseUri;
            _webBrowserDriver = new ChromeDriver(); // TODO: Inject
        }

        /// <summary>
        /// Returns a collection of all the classes in all the loaded assemblies that inherit from the WebPage class.
        /// </summary>
        /// <returns>Returns a collection of Types, keyed on the relative path of the WebPage.</returns>
        static 
        Dictionary<string, Type> 
        GetWellKnownPages()
        {
            var types = Assembly
                .GetExecutingAssembly()
                .GetTypes();

            var wellKnownPages = new Dictionary<string, Type>();

            foreach (var type in types.Where(t => typeof(WebPage).IsAssignableFrom(t) && !t.IsAbstract))
            {
                var relativePathField = type
                    .GetFields(BindingFlags.Public | BindingFlags.Static)
                    .SingleOrDefault(fi => 
                        fi.IsLiteral && 
                        !fi.IsInitOnly && 
                        fi.Name == WebPageRelativePathConstantName
                    );

                if (relativePathField == null)
                    throw new InvalidOperationException(
                        string.Format(
                            "You must add a public string constant named {0} to type {1} before it can be used.", 
                            WebPageRelativePathConstantName, 
                            type.FullName
                        )
                    );

                wellKnownPages.Add(
                    relativePathField.GetRawConstantValue().ToString(), 
                    type
                );
            }

            return wellKnownPages;
        }

        /// <summary>
        /// Directs the browser to navigate directly to the specified TPage, 
        /// as if the user typed the URL directly in the browsers address bar.
        /// </summary>
        /// <typeparam name="TPage">
        /// Specifies the well known WebPage to navigate to.
        /// The address of the WebPage will be generated by combining the Base URI and the RelativePath constant of the inheriting WebPage class.
        /// </typeparam>
        /// <returns>
        /// Returns an instance of WebPage that represents the current web page.
        /// Remember that it is possible to end up on a web page that is different than what was requested by TPage.
        /// </returns>
        public
        TPage NavigateTo<TPage>() where TPage: WebPage
        {
            var relativeUri = WellKnownPages.Single(pair => pair.Value == typeof (TPage)).Key;

            var fullyQualifiedUri = new Uri(
                _baseUri,
                relativeUri
            );

            _webBrowserDriver
                .Navigate()
                .GoToUrl(fullyQualifiedUri);

            return GetCurrentPageAs<TPage>();
        }

        /// <summary>
        /// Attempts to get an instance of the current WebPage as the specified TPage type.
        /// </summary>
        /// <typeparam name="TPage">Specifies the type of WebPage that is expected.</typeparam>
        /// <returns>
        /// If the current WebPage is of type TPage, then an instance of WebPage modeling TPage will be returned.
        /// Otherwise, null will be returned.
        /// </returns>
        public TPage GetCurrentPageAs<TPage>() where TPage : WebPage
        {
            var uri = new Uri(_webBrowserDriver.Url);
            var path = uri.AbsolutePath;

            var match = WellKnownPages.FirstOrDefault(kvp => kvp.Key == path);

            if (match.Key == null)
                throw new Exception("Could not find a matching page for path " + path);

            var pageType = match.Value;

            return (TPage)Activator.CreateInstance(pageType, _webBrowserDriver);
        }
        
        /// <summary>
        /// Frees any resources allocated by this instance.
        /// </summary>
        public void Dispose()
        {
            _webBrowserDriver.Dispose();
        }
    }
}